<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>接口流量控制 | lizhouwei</title>
    <meta name="description" content="博学之，审问之，慎思之，眀辨之，笃行之">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
    
    <link rel="preload" href="/assets/css/0.styles.3e1d0bd1.css" as="style"><link rel="preload" href="/assets/js/app.b754686d.js" as="script"><link rel="preload" href="/assets/js/40.128c670d.js" as="script"><link rel="prefetch" href="/assets/js/10.dc6a57bc.js"><link rel="prefetch" href="/assets/js/11.05a7896a.js"><link rel="prefetch" href="/assets/js/12.87f729cc.js"><link rel="prefetch" href="/assets/js/13.b783eb80.js"><link rel="prefetch" href="/assets/js/14.fe15610f.js"><link rel="prefetch" href="/assets/js/15.4d747cf5.js"><link rel="prefetch" href="/assets/js/16.12cc21ce.js"><link rel="prefetch" href="/assets/js/17.87e584b1.js"><link rel="prefetch" href="/assets/js/18.a408f5f0.js"><link rel="prefetch" href="/assets/js/19.e175f669.js"><link rel="prefetch" href="/assets/js/2.81340e14.js"><link rel="prefetch" href="/assets/js/20.c6e6f090.js"><link rel="prefetch" href="/assets/js/21.b92c5565.js"><link rel="prefetch" href="/assets/js/22.eb576cbd.js"><link rel="prefetch" href="/assets/js/23.08a7db77.js"><link rel="prefetch" href="/assets/js/24.d61aae73.js"><link rel="prefetch" href="/assets/js/25.09c47cf9.js"><link rel="prefetch" href="/assets/js/26.116135c4.js"><link rel="prefetch" href="/assets/js/27.d0014973.js"><link rel="prefetch" href="/assets/js/28.9267b2b6.js"><link rel="prefetch" href="/assets/js/29.41694a7d.js"><link rel="prefetch" href="/assets/js/3.df97d12b.js"><link rel="prefetch" href="/assets/js/30.02a18457.js"><link rel="prefetch" href="/assets/js/31.a2736d54.js"><link rel="prefetch" href="/assets/js/32.b6f1a898.js"><link rel="prefetch" href="/assets/js/33.2327629e.js"><link rel="prefetch" href="/assets/js/34.d381e84e.js"><link rel="prefetch" href="/assets/js/35.61f98868.js"><link rel="prefetch" href="/assets/js/36.4c841ea5.js"><link rel="prefetch" href="/assets/js/37.681ae4cb.js"><link rel="prefetch" href="/assets/js/38.58a9ee5e.js"><link rel="prefetch" href="/assets/js/39.4b09873b.js"><link rel="prefetch" href="/assets/js/4.283ac3a2.js"><link rel="prefetch" href="/assets/js/41.4e5a175a.js"><link rel="prefetch" href="/assets/js/42.9931eddc.js"><link rel="prefetch" href="/assets/js/43.865cca26.js"><link rel="prefetch" href="/assets/js/44.5755d469.js"><link rel="prefetch" href="/assets/js/45.febddf97.js"><link rel="prefetch" href="/assets/js/46.7562b5b2.js"><link rel="prefetch" href="/assets/js/5.57704351.js"><link rel="prefetch" href="/assets/js/6.955fc97c.js"><link rel="prefetch" href="/assets/js/7.0d473d0c.js"><link rel="prefetch" href="/assets/js/8.156d9fda.js"><link rel="prefetch" href="/assets/js/9.9d034739.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3e1d0bd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">lizhouwei</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/java/" class="nav-link">java语言</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">数据结构与算法</a></div><div class="nav-item"><a href="/framework/" class="nav-link router-link-active">框架</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lizhouwei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.cnblogs.com/lizhouwei/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客园
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/java/" class="nav-link">java语言</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">数据结构与算法</a></div><div class="nav-item"><a href="/framework/" class="nav-link router-link-active">框架</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lizhouwei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.cnblogs.com/lizhouwei/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客园
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>spring</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/framework/spring/" class="sidebar-link">文章目录</a></li><li><a href="/framework/spring/接口流量控制.html" class="active sidebar-link">接口流量控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#漏桶算法" class="sidebar-link">漏桶算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#实现原理" class="sidebar-link">实现原理</a></li><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#代码示例" class="sidebar-link">代码示例</a></li></ul></li><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#令牌算法" class="sidebar-link">令牌算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#实现原理-2" class="sidebar-link">实现原理</a></li><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#guava-ratelimiter" class="sidebar-link">Guava RateLimiter</a></li></ul></li><li class="sidebar-sub-header"><a href="/framework/spring/接口流量控制.html#两种算法的区别" class="sidebar-link">两种算法的区别</a></li></ul></li><li><a href="/framework/spring/GuavaRateLimiter.html" class="sidebar-link">RateLimiter源码</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>spring-core</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>spring-beans</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>spring-aop</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>springBoot</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="接口流量控制"><a href="#接口流量控制" aria-hidden="true" class="header-anchor">#</a> 接口流量控制</h1> <h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能时则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限制流量。</p> <p>限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</p> <p>一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p> <p>在实际的场景中常用的限流策略有：</p> <h2 id="漏桶算法"><a href="#漏桶算法" aria-hidden="true" class="header-anchor">#</a> 漏桶算法</h2> <p>漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形，从而为网络提供一个稳定的流量。</p> <h3 id="实现原理"><a href="#实现原理" aria-hidden="true" class="header-anchor">#</a> 实现原理</h3> <p>如下图所示，,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率。<br> <img src="/LeakyBucket_01.png" alt="An image"><br>
可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(Bucket),另一个是水桶漏洞的大小(Rate)。</p> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>因为漏桶的漏出速率是固定的参数,当使用了漏桶算法，我们可以保证接口会以一个常速速率来处理请求。所以漏桶算法天生不会出现临界问题.</p></div> <h3 id="代码示例"><a href="#代码示例" aria-hidden="true" class="header-anchor">#</a> 代码示例</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeakyBucket</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span> <span class="token comment">// 桶的容量</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> rate<span class="token punctuation">;</span> <span class="token comment">// 水漏出的速度</span>
  <span class="token keyword">public</span> <span class="token class-name">Long</span> water<span class="token punctuation">;</span> <span class="token comment">// 当前水量(当前累积请求数)</span>

  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">grant</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    water <span class="token operator">=</span> water <span class="token operator">-</span> rate<span class="token punctuation">;</span> <span class="token comment">// 先执行漏水，计算剩余水量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>water <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 水满，拒绝加水</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
      <span class="token comment">// 尝试加水,并且水还未满</span>
    water <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="令牌算法"><a href="#令牌算法" aria-hidden="true" class="header-anchor">#</a> 令牌算法</h2> <p>令牌桶算法(Token Bucket)是指系统会按恒定1/QPS时间间隔（如果QPS=100,则间隔是10ms）往桶里加入Token，如果桶已满就停止产生Token。当新请求来临时，会各自拿走一个Token，如果没有Token可拿了就阻塞或者拒绝服务。</p> <h3 id="实现原理-2"><a href="#实现原理-2" aria-hidden="true" class="header-anchor">#</a> 实现原理</h3> <p>如下图所示，大小固定的令牌桶可自行以恒定的速率不断地产生令牌。如果令牌不被消耗，或者被消耗的速度小于产生的速度，令牌就会不断地增多，直到把桶填满。后面再产生的令牌就会从桶中溢出。最后桶中保存的最大令牌数永远不会超过桶的大小。<br> <img src="/tokenBucket_01.png" alt="An image"><br>
从图中我们可以看到，首先，我们有一个固定容量的桶，桶里存放着令牌（Token）。桶一开始是空的，Token以一个固定的速率 r 往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。每当一个请求过来时，就会尝试从桶里拿走一个Token，如果没有Token的话，请求无法通过。</p> <p>令牌桶的另外一个好处是可以方便的改变速度。一旦需要提高速率，则按需提高放入桶中的令牌的速率。一般会定时（比如100毫秒）往桶中增加一定数量的令牌，有些变种算法会实时的计算应该增加的令牌的数量。</p> <h3 id="guava-ratelimiter"><a href="#guava-ratelimiter" aria-hidden="true" class="header-anchor">#</a> Guava RateLimiter</h3> <p>首先用maven 引入Guava</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>
    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>guava<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>guava<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">23.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span>
</code></pre></div><p>Guava RateLimiter提供了令牌桶算法实现：<br>
Guava中开源出来一个令牌桶算法的工具类RateLimiter，可以轻松实现限流的工作。RateLimiter 对简单的令牌桶算法做了一些工程上的优化，具体的实现是<strong>SmoothBursty（平滑突发限流）</strong>。需要注意的是，RateLimiter 的另一个实现<strong>SmoothWarmingUp（平滑预热限流）</strong>，就不是令牌桶了，而是漏桶算法。也许是出于简单起见，RateLimiter 中的时间窗口能且仅能为 1s，如果想搞其他时间单位的限流，只能另外造轮子。<br> <strong>SmoothBursty（平滑突发限流）的RateLimiter创建示例</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//permitsPerSecond表示每秒新增的令牌数，为double类型</span>
<span class="token class-name">RateLimiter</span> rateLimiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">double</span> permitsPerSecond<span class="token punctuation">)</span> <span class="token punctuation">;</span>

<span class="token comment">//例如：每秒往桶里扔1000个Token，即QPS最大为1000</span>
<span class="token class-name">RateLimiter</span> limiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>RateLimiter 有一个有趣的特性是「前人挖坑后人跳」，也就是说 RateLimiter 允许某次请求拿走超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。这里面就涉及到一个权衡，是让前一次请求干等到令牌够用才走掉呢，还是让它先走掉后面的请求等一等呢？Guava 的设计者选择的是后者，先把眼前的活干了，后面的事后面再说。<br>
例如以下示例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimiterMain</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">RateLimiter</span> rateLimiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">0.0</span>
<span class="token number">2.495981</span>
<span class="token number">0.994386</span>
</code></pre></div><p>可以看出，令牌桶每秒只能产生2个令牌，第一次取出5个后，第二个再去取令牌的时候，需要等2.495981s，也就是第一次令牌取完后，需要等2.495981s才能取到令牌。同样的，第三次取1个令牌的时候，也需要等待第二次的0.994386s的时间。也就是，取的速率可以超过令牌产生的速率，但是下一次再次去取的时候，需要阻塞等待。<strong>方法acquire()返回的是获取Token要等待的时间</strong></p> <p>当然也可以使用tryAcquire来非阻塞的获取，可以实时返回结果。另外tryAcquire也可以传入参数，也就是等待的时间，超时直接返回false。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimiterMain</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">RateLimiter</span> rateLimiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">false</span>
</code></pre></div><p>tryAcquire设置时间参数的示例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RateLimiterMain</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">RateLimiter</span> rateLimiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rateLimiter<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>由于RateLimiter是属于单位时间内生成多少个Token，譬如0.1秒生成1个Token，那获取Token就要看运气了，如果请求在刚生成1个Token时进来并抢到Token，那么在这0.1秒内其他的请求只能寄希望于下一个0.1秒，从用户体验上来说，不能让请求一直阻塞等待，所以就需要迅速判断，该请求在某段时间内，还有没有机会得到Token，而使用<code>tryAcquire(long timeout, TimeUnit unit)</code>方法时，指定一个超时时间，一旦判断出在timeout时间内还无法取得令牌，就返回false。<strong>注意，这里并不是真正的等待了timeout时间，而是判断即便过了timeout时间，也无法取得令牌。这个是不需要等待的</strong>。</p></div> <p>因为SmoothBursty允许一定程度的突发，假设突然间来了很大的流量，那么系统很可能扛不住这种突发。因此需要一种平滑速率的限流工具，从而系统冷启动后慢慢的趋于平均固定速率（即刚开始速率小一些，然后慢慢趋于我们设置的固定速率）。Guava也提供了SmoothWarmingUp来实现这种需求，其可以认为是漏桶算法，但是在某些特殊场景又不太一样。</p> <p><strong>SmoothWarmingUp（平滑预热限流）</strong><br>
在程序刚开始运行的时候，warmingup方式会存满所有的令牌，而根据从存储令牌中的获取方式，可以实现从存储最大令牌中到降到一半令牌所需要的时间为存储同量令牌时间的2倍，从而使得刚开始的时候发放令牌的速度比较慢，等消耗一半之后，获取的速率和生产的速率一致，从而也就实现了一个‘热身’的概念<br>
的RateLimiter创建示例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//permitsPerSecond表示每秒新增的令牌数，warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔</span>
<span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>doublepermitsPerSecond<span class="token punctuation">,</span> <span class="token keyword">long</span> warmupPeriod<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>

<span class="token comment">//例如：</span>
<span class="token class-name">RateLimiter</span> limiter <span class="token operator">=</span> <span class="token class-name">RateLimiter</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="两种算法的区别"><a href="#两种算法的区别" aria-hidden="true" class="header-anchor">#</a> 两种算法的区别</h2> <p>两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，所以它适合于具有突发特性的流量。</p> <p>参考：<br> <a href="https://jinnianshilongnian.iteye.com/blog/2305117" target="_blank" rel="noopener noreferrer">聊聊高并发系统之限流特技<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.b754686d.js" defer></script><script src="/assets/js/40.128c670d.js" defer></script>
  </body>
</html>
